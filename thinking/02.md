### Thinking

**1. 如何使用用户标签来指导业务（如何提升业务）**

标签能帮助我们：1. 完善数据仓库；2. 以标签为维度进行业务应用；3.以标签为维度的数据分析。

- 对于用户的了解越多，越有利于通过产品优化进行用户增长和留存，企业或市场要有自己的数据仓库来进行线索的存储和培育，用户标签的存在就是于此，若用户的标签尽可能的***完整***，我们会认为仓库越发丰富***有价值***。如同样有1万人，只有电话号的数据仓库肯定没有信息相对齐全的数据仓库价值高。
- 以标签为维度进行业务应用，我们进行打签的时候要设置好标签的分类和入库规则，这样就可以根据某个标签进行数据抽取，如电商平台，1万人的数据库经过查询有3000人打上了同一种标签，就是收藏了预售的MacBook，这时候就可以指定相应的***精准营销***计划。另外一个标签的用法就是，个性化内容商品推荐，根据标签进行相应的内容展示，提高内容的点击率，根据标签进行相应的商品展示，提高商品曝光，无论是做哪种相关推荐，都会较无相关的展示相对精准。
- 以标签的***多维度***分析，例如以性别维度进行分析统计，以行业进行分析统计，若以用户的首次来源作为标签，还可以了解用户的渠道信息。

**2. 若给你一堆用户数据，没有打标签。你该如何处理（如何打标签）**

打标签的方式有三种方式：手动打标签、自动打标签、数据上报打标签

- 手动打标签，是数据上报打标签的一种形式，在一个成熟的***交互页面***里给用户打标签。常用的情景，用户线下参会，但是并没有数字化的会议管理，我们拿到了用户的数据资料无法同步到系统里，这时候就需要我们动手给用户打相应的标签，若系统里有打分的功能，还要把参会的分数打上。手动打标签的优点是***灵活***，随需随打，但是缺点就是在用户量增大的时候，工作量变得极大，***标签规范变得偏混乱***。
- 自动打标签，在数据仓库之外进行相应的***标签规则***设定以及计算，在用户与数据仓库进行交互的时候，同步用户标签。常见的应用场景，电商环境里给用户打的品类标签，用户没有进行品类关注，但是我们可以通过规则计算，用户触发的100个商品里，有70%以上是属于母婴类，或者用户过去30天购买的商品里有30%是母婴类，我们都会自动给用户打上母婴的标签，自动打标签的优点是使用范围广泛且方便好用，只需要规则即可，缺点就是需要自己制定计算模型，同时要验证准确性。在自动打标签上，及时再完善的模型，也会存在一些不准确。
- 推荐标签，如一些招聘网站boss直聘等。

**3. 准确率和精确率有何不同（评估指标）**

- 准确率$Accuracy=\frac{n_{correct}}{n_{total}}$，其中$n_{correct}$为被正确分类的样本个数，$n_{total}$为总样本的个数。表示准确率是分类问题中最简单也是最直观的评价指标，但是存在明显的缺陷，如当负样本占$99\%$时，分类器把所有样本都预测为负样本也可以获得$99\%$的准确率。所以，当不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。
- 精确度$Precision=\frac{TP}{TP+FP}$，是指分类正确的正样本个数占分类器判定为正样本的样本个数的比例。
- 分类正确率（Accuracy），不管是哪个类别，只要预测正确，其数量都放在分子上，而分母是全部数据数量，这说明正确率是对全部数据的判断。而准确率在分类中对应的是某个类别，分子是预测该类别正确的数量，分母是预测为该类别的全部数据的数量。或者说，Accuracy是对***分类器整体上的正确率的评价***，而Precision是分类器预测为***某一个类别***的正确率的评价。

**4. 如果你使用大众点评，想要给某个餐厅打标签。这时候系统会自动提示一些标签，你会如何设计（标签推荐）**

- 给用户$u$推荐整个系统最热门的标签（这个算法称为***PopularTags***），令$tags[b]$为标签$b$的热门程度，算法实现如下：

  ```python
  def recommend_popular_tags(user, item, tags, N):
      return sorted(tags.item(), key=itemgetter(1), reverse=True)[0:N]
  ```

- 给用户$u$推荐物品$i$上最热门的标签（这个算法称为***ItemPopularTags***），令$item_tags[i][b]$表示物品$i$被打上标签$b$的次数，算法实现如下：

  ```python
  def recommend_item_popular_tags(user, item, item_tags, N):
      return sorted(item_tags[item].items(), key=itemgetter(1), reverse=True)[0:N]
  ```

- 给用户$u$推荐他自己常使用的标签（这里将这个算法称为***UserPopularTags***），令$user_tags[u][b]$为用户$u$使用标签$b$的次数，算法实现如下：

  ```python
  def recommend_user_popular_tags(user, item, user_tags, N):
      return sorted(user_tags[user].items(), key=itemgetter(1), reverse=True)
  ```

- 前面两种的融合（***HybridPopularTags***），该方法通过一个系数将上面的推荐结果线性加权，然后生成最终的推荐结果：

  ```python
  def recommend_hybrid_popular_tags(user, item, user_tags, alpha, N):
      max_item_tag_weight = max(item_tags[item].values())
      for tag, weight in item_tags[item].items():
          if tag not in ret:
              ret[tag] = alpha * weight / max_item_tag_weight
          else:
              ret[tag] += alpha * weight / max_item_tag_weight
  ```

  

**5. 我们今天使用10种方式来解MNIST，这些方法有何不同？你还有其他方法来解决MNIST识别问题？（分类方法）**

- 使用Logistic Regression，需要不需要对数据进行处理，并且速度上很快，使用
- 模型融合
  - 平均法$H(x)=\sum_{i=1}^Tw_ih_i(x)$，把单模型的输出进行加权平均.
  - 投票法
  - Bagging，利用Boostrap和Aggregation，自助采样单模型，融合模型.
  - Stacking
- CNN/RNN/ResNet

## References

[1. https://ark.analysys.cn/blog/1215](https://ark.analysys.cn/blog/1215)

[2. 百面机器学习](https://book.douban.com/subject/30285146/)

[3. https://www.cnblogs.com/zhizhan/p/4870429.html](https://www.cnblogs.com/zhizhan/p/4870429.html)

[4. https://tech.meituan.com/2020/01/17/meituan-tech-blog-2019.html](https://tech.meituan.com/2020/01/17/meituan-tech-blog-2019.html)

[5. https://blog.csdn.net/Gamer_gyt/article/details/51684716](https://blog.csdn.net/Gamer_gyt/article/details/51684716)

[6. Numpy](https://www.kaggle.com/python10pm/learn-numpy-the-hard-way-70-exercises-solutions)

[7. https://www.cnblogs.com/wentingtu/archive/2012/03/18/2404543.html](https://www.cnblogs.com/wentingtu/archive/2012/03/18/2404543.html)





